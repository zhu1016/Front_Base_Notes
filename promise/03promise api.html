<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
      <!-- 
    1. Promise构造函数: new Promise (executor) {}
					executor函数: 是同步执行的，(resolve, reject) => {}
					resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。
					reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。
					说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。

    2. Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)
					onFulfilled: 成功的回调函数 (value) => {}
					onRejected: 失败的回调函数 (reason) => {}
					特别注意(难点)：then方法会返回一个新的Promise实例对象

    3. Promise.prototype.catch方法: Promise实例.catch(onRejected)
          onRejected: 失败的回调函数 (reason) => {}
          说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected)

    4. Promise.resolve方法: Promise.resolve(value)
					说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象
					备注：value的值可能是：(1)非Promise值  (2)Promise值

		5. Promise.reject方法: Promise.reject方法(reason)
          说明: 用于快速返回一个状态必为rejected的Promise实例对象
		
    6. Promise.all方法: Promise.all(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。
				
    7. Promise.race方法: Promise.race(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。
	-->

    	<!-- 
		 	Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?
					1.简单表达: 由then()所指定的回调函数执行的结果决定
					2.详细表达:
							(1)如果then所指定的回调返回的是非Promise值a:
											那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a
							(2)如果then所指定的回调返回的是一个Promise实例p:
											那么【新Promise实例】的状态、值，都与p一致
							(3)如果then所指定的回调抛出异常:
											那么【新Promise实例】状态为rejected, reason为抛出的那个异常
	 -->





     	<!-- 
		中断promise链：
					(1)当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。
					(2)办法: 在失败的回调函数中返回一个pendding状态的Promise实例。  return new Promise(()=>{})
	 -->




     <!-- 
			promise错误穿透：
					(1)当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调,
					(2)前面任何操作出了错误, 都会传到最后失败的回调中处理了
			备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。
	 -->
</body>
</html>